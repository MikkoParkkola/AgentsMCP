"""
V4 Workspace Controller - Persistent TUI Manager for Agent Orchestration

This is the Mission Control Center for AI agents - a persistent interface that never exits
and provides real-time orchestration of agent workflows, like htop/k9s but for AI agents.

Key Features:
- Persistent event loop that never exits on EOF
- Non-blocking keyboard input handling
- Live agent display with status and progress
- Interactive controls for spawning/managing agents
- Real-time updates showing agent activity
- Sequential thinking display area
"""
import asyncio
import sys
import os
import time
import threading
import json
from datetime import datetime
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set
from enum import Enum
from collections import deque
import uuid
import logging

from rich.console import Console
from rich.live import Live
from rich.layout import Layout
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.columns import Columns
from rich.progress import Progress, TaskID, BarColumn, TimeElapsedColumn, TextColumn
from rich.align import Align
from rich import box


logger = logging.getLogger(__name__)


class AgentStatus(Enum):
    """Agent execution status"""
    SPAWNING = "spawning"
    THINKING = "thinking" 
    EXECUTING = "executing"
    WAITING = "waiting"
    COMPLETED = "completed"
    ERROR = "error"
    PAUSED = "paused"
    KILLED = "killed"


@dataclass
class Agent:
    """Represents a spawned agent in the workspace"""
    id: str
    name: str
    command: str
    status: AgentStatus
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    progress: float = 0.0
    current_task: str = ""
    sequential_thoughts: deque = field(default_factory=lambda: deque(maxlen=10))
    output_lines: deque = field(default_factory=lambda: deque(maxlen=100))
    error_count: int = 0
    last_activity: datetime = field(default_factory=datetime.now)
    
    def add_thought(self, thought: str):
        """Add a sequential thinking step"""
        self.sequential_thoughts.append({
            'timestamp': datetime.now(),
            'thought': thought
        })
        self.last_activity = datetime.now()
    
    def add_output(self, line: str):
        """Add an output line"""
        self.output_lines.append({
            'timestamp': datetime.now(),
            'line': line
        })
        self.last_activity = datetime.now()


@dataclass 
class WorkspaceState:
    """Current state of the workspace"""
    agents: Dict[str, Agent] = field(default_factory=dict)
    selected_agent_id: Optional[str] = None
    view_mode: str = "overview"  # overview, agent_detail, thinking, logs
    status_message: str = "Workspace Ready"
    total_agents_spawned: int = 0
    active_agents: int = 0
    keyboard_shortcuts_visible: bool = True
    # Chat input state
    chat_input_text: str = ""
    chat_input_mode: bool = False  # True when user is typing a command
    chat_history: List[str] = field(default_factory=list)
    chat_cursor_position: int = 0
    
    
class KeyboardHandler:
    """Non-blocking keyboard input handler"""
    
    def __init__(self):
        self.key_buffer = deque(maxlen=100)
        self._running = False
        self._thread = None
        
    def start(self):
        """Start the non-blocking keyboard handler"""
        if self._running:
            return
            
        self._running = True
        self._thread = threading.Thread(target=self._keyboard_loop, daemon=True)
        self._thread.start()
        
    def stop(self):
        """Stop the keyboard handler"""
        self._running = False
        
    def get_key(self) -> Optional[str]:
        """Get the next key if available"""
        try:
            return self.key_buffer.popleft()
        except IndexError:
            return None
            
    def _keyboard_loop(self):
        """Background thread for keyboard input"""
        try:
            import termios, tty
            old_settings = termios.tcgetattr(sys.stdin)
            tty.setcbreak(sys.stdin.fileno())
            
            while self._running:
                try:
                    import select
                    if select.select([sys.stdin], [], [], 0.1)[0]:
                        key = sys.stdin.read(1)
                        if key:
                            self.key_buffer.append(key)
                except:
                    # Fallback for systems without select
                    time.sleep(0.1)
                    
        except Exception as e:
            # Fallback for systems without termios
            pass
        finally:
            try:
                termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
            except:
                pass


class WorkspaceController:
    """Persistent TUI Manager for Agent Orchestration"""
    
    def __init__(self):
        self.console = Console()
        self.workspace_state = WorkspaceState()
        self.keyboard_handler = KeyboardHandler()
        self.layout = None
        self.live = None
        self._running = False
        self._last_render = 0
        self._render_interval = 0.1  # 10 FPS
        
        # Initialize MCP integrations
        self.mcp_orchestrator = None
        self.thinking_integrator = None
        self._integration_initialized = False
        
        # Initialize layout
        self._setup_layout()
        
    async def _initialize_mcp_integration(self):
        """Initialize MCP agent orchestrator and sequential thinking integrator."""
        if self._integration_initialized:
            return
            
        try:
            # Initialize MCP orchestrator
            from .mcp_agent_orchestrator import create_orchestrator
            self.mcp_orchestrator = await create_orchestrator()
            
            # Set up callbacks for UI updates
            self.mcp_orchestrator.add_status_callback(self._on_agent_status_update)
            self.mcp_orchestrator.add_thinking_callback(self._on_agent_thinking_update)
            self.mcp_orchestrator.add_output_callback(self._on_agent_output_update)
            self.mcp_orchestrator.add_process_coach_callback(self._on_process_coach_update)
            
            # Initialize sequential thinking integrator
            from .sequential_thinking_integrator import create_thinking_integrator
            self.thinking_integrator = await create_thinking_integrator()
            
            # Set up thinking callbacks
            self.thinking_integrator.add_thinking_callback(self._on_thinking_step_update)
            self.thinking_integrator.add_session_callback(self._on_thinking_session_update)
            
            self._integration_initialized = True
            logger.info("MCP integration initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize MCP integration: {e}")
            # Continue with demo mode
            self._integration_initialized = False
    
    def _on_agent_status_update(self, session_id: str, status_data: Dict[str, Any]):
        """Handle agent status updates from MCP orchestrator."""
        try:
            # Map MCP session to workspace agent
            if session_id not in self.workspace_state.agents:
                # Create new agent entry
                agent = Agent(
                    id=session_id[:8],
                    name=status_data.get('agent_type', 'Unknown'),
                    command=status_data.get('objective', ''),
                    status=self._map_status(status_data.get('status', 'unknown')),
                    created_at=datetime.now()
                )
                self.workspace_state.agents[session_id] = agent
            else:
                agent = self.workspace_state.agents[session_id]
            
            # Update agent from status data
            if 'status' in status_data:
                agent.status = self._map_status(status_data['status'])
            if 'progress' in status_data:
                agent.progress = status_data['progress']
            if 'objective' in status_data:
                agent.current_task = status_data['objective']
                
        except Exception as e:
            logger.error(f"Error handling agent status update: {e}")
    
    def _on_agent_thinking_update(self, session_id: str, thought: str):
        """Handle thinking updates from MCP agents."""
        if session_id in self.workspace_state.agents:
            agent = self.workspace_state.agents[session_id]
            agent.add_thought(thought)
    
    def _on_agent_output_update(self, session_id: str, output: str):
        """Handle output updates from MCP agents."""
        if session_id in self.workspace_state.agents:
            agent = self.workspace_state.agents[session_id]
            agent.add_output(output)
    
    def _on_thinking_step_update(self, session_id: str, step):
        """Handle sequential thinking step updates."""
        if session_id in self.workspace_state.agents:
            agent = self.workspace_state.agents[session_id]
            thought_text = f"[{step.phase.value.upper()}] {step.thought}"
            agent.add_thought(thought_text)
    
    def _on_thinking_session_update(self, session_id: str, update_data: Dict[str, Any]):
        """Handle thinking session updates."""
        if session_id in self.workspace_state.agents:
            agent = self.workspace_state.agents[session_id]
            update_type = update_data.get('type')
            
            if update_type == 'session_started':
                agent.add_output("üß† Sequential thinking session started")
            elif update_type == 'session_completed':
                final_answer = update_data.get('final_answer', '')
                agent.add_output(f"üéØ Final answer: {final_answer}")
    
    def _on_process_coach_update(self, message: str, cycle_data: Dict[str, Any]):
        """Handle Process Coach improvement cycle updates."""
        self._last_process_coach_message = message
        self.workspace_state.status_message = f"üß† Process Coach: {message}"
        
        # Clear the message after 10 seconds
        import threading
        def clear_message():
            import time
            time.sleep(10)
            if hasattr(self, '_last_process_coach_message'):
                self._last_process_coach_message = ""
        
        threading.Thread(target=clear_message, daemon=True).start()
    
    def _map_status(self, mcp_status: str) -> AgentStatus:
        """Map MCP agent status to workspace agent status."""
        status_mapping = {
            'spawning': AgentStatus.SPAWNING,
            'thinking': AgentStatus.THINKING,
            'executing': AgentStatus.EXECUTING,
            'waiting': AgentStatus.WAITING,
            'completed': AgentStatus.COMPLETED,
            'error': AgentStatus.ERROR,
            'paused': AgentStatus.PAUSED,
            'cancelled': AgentStatus.KILLED,
            'killed': AgentStatus.KILLED
        }
        return status_mapping.get(mcp_status.lower(), AgentStatus.WAITING)
        
    def _setup_layout(self):
        """Setup the TUI layout structure"""
        self.layout = Layout(name="root")
        
        # Split into main sections - add chat input at bottom
        self.layout.split_column(
            Layout(name="header", size=3),
            Layout(name="main", ratio=1),
            Layout(name="chat_input", size=4),  # New chat input panel
            Layout(name="footer", size=2)
        )
        
        # Split main section
        self.layout["main"].split_row(
            Layout(name="agents_panel", ratio=2),
            Layout(name="detail_panel", ratio=3)
        )
        
        # Split detail panel
        self.layout["detail_panel"].split_column(
            Layout(name="thinking_panel", ratio=1),
            Layout(name="output_panel", ratio=1)
        )
        
    def _render_header(self) -> Panel:
        """Render the header panel"""
        current_time = datetime.now().strftime("%H:%M:%S")
        
        header_text = Text()
        header_text.append("üöÄ AgentsMCP Workspace Controller", style="bold cyan")
        header_text.append(" | ", style="white")
        header_text.append(f"Time: {current_time}", style="blue")
        header_text.append(" | ", style="white") 
        header_text.append(f"Active: {self.workspace_state.active_agents}", style="green")
        header_text.append(" | ", style="white")
        header_text.append(f"Total: {self.workspace_state.total_agents_spawned}", style="yellow")
        
        # Add Process Coach status if MCP is available
        if self._integration_initialized and self.mcp_orchestrator:
            try:
                completed_count = sum(1 for agent in self.workspace_state.agents.values() 
                                    if agent.status == AgentStatus.COMPLETED)
                
                header_text.append(" | ", style="white")
                header_text.append("üß† Coach: ", style="magenta")
                
                if completed_count >= 5:
                    header_text.append("ACTIVE", style="bold green")
                else:
                    header_text.append(f"{completed_count}/5", style="cyan")
                    
            except Exception:
                # Gracefully handle any Process Coach status errors
                pass
        
        return Panel(
            Align.center(header_text),
            style="cyan",
            box=box.ROUNDED
        )
        
    def _render_agents_panel(self) -> Panel:
        """Render the agents overview panel"""
        table = Table(show_header=True, header_style="bold magenta", box=box.SIMPLE)
        table.add_column("ID", style="cyan", width=8)
        table.add_column("Name", style="white", width=15)
        table.add_column("Status", width=12)
        table.add_column("Progress", width=10)
        table.add_column("Task", style="dim", no_wrap=False)
        
        for agent_id, agent in self.workspace_state.agents.items():
            # Status styling
            status_style = {
                AgentStatus.SPAWNING: "yellow",
                AgentStatus.THINKING: "blue",
                AgentStatus.EXECUTING: "green", 
                AgentStatus.WAITING: "cyan",
                AgentStatus.COMPLETED: "bright_green",
                AgentStatus.ERROR: "red",
                AgentStatus.PAUSED: "orange1",
                AgentStatus.KILLED: "dim red"
            }.get(agent.status, "white")
            
            # Progress bar
            progress_bar = "‚ñà" * int(agent.progress * 10) + "‚ñë" * (10 - int(agent.progress * 10))
            progress_text = f"{progress_bar} {agent.progress:.0%}"
            
            # Highlight selected agent
            row_style = "on blue" if agent_id == self.workspace_state.selected_agent_id else None
            
            table.add_row(
                agent_id[:8],
                agent.name,
                agent.status.value,
                progress_text,
                agent.current_task[:50] + "..." if len(agent.current_task) > 50 else agent.current_task,
                style=row_style
            )
            
        if not self.workspace_state.agents:
            table.add_row(
                "-", "No agents running", "-", "-", "Press 'n' to spawn a new agent",
                style="dim"
            )
            
        return Panel(
            table,
            title="ü§ñ Active Agents",
            border_style="blue"
        )
        
    def _render_thinking_panel(self) -> Panel:
        """Render the sequential thinking panel"""
        if not self.workspace_state.selected_agent_id:
            return Panel(
                Align.center("Select an agent to view thinking", vertical="middle"),
                title="üß† Sequential Thinking",
                border_style="green",
                style="dim"
            )
            
        agent = self.workspace_state.agents.get(self.workspace_state.selected_agent_id)
        if not agent:
            return Panel(
                Align.center("Agent not found", vertical="middle"),
                title="üß† Sequential Thinking",
                border_style="red"
            )
            
        thinking_text = Text()
        
        if not agent.sequential_thoughts:
            thinking_text.append("No thinking steps yet...", style="dim")
        else:
            for i, thought_data in enumerate(agent.sequential_thoughts):
                timestamp = thought_data['timestamp'].strftime("%H:%M:%S")
                thought = thought_data['thought']
                
                thinking_text.append(f"[{timestamp}] ", style="dim blue")
                thinking_text.append(f"Step {i+1}: ", style="bold yellow")
                thinking_text.append(f"{thought}\n\n", style="white")
                
        return Panel(
            thinking_text,
            title=f"üß† Sequential Thinking - {agent.name}",
            border_style="green",
            height=15
        )
        
    def _render_output_panel(self) -> Panel:
        """Render the output/logs panel"""
        if not self.workspace_state.selected_agent_id:
            return Panel(
                Align.center("Select an agent to view output", vertical="middle"),
                title="üìÑ Output & Logs", 
                border_style="yellow",
                style="dim"
            )
            
        agent = self.workspace_state.agents.get(self.workspace_state.selected_agent_id)
        if not agent:
            return Panel(
                Align.center("Agent not found", vertical="middle"),
                title="üìÑ Output & Logs",
                border_style="red"
            )
            
        output_text = Text()
        
        if not agent.output_lines:
            output_text.append("No output yet...", style="dim")
        else:
            for output_data in agent.output_lines:
                timestamp = output_data['timestamp'].strftime("%H:%M:%S")
                line = output_data['line']
                
                output_text.append(f"[{timestamp}] ", style="dim blue")
                output_text.append(f"{line}\n", style="white")
                
        return Panel(
            output_text,
            title=f"üìÑ Output & Logs - {agent.name}",
            border_style="yellow"
        )
        
    def _render_footer(self) -> Panel:
        """Render the footer with keyboard shortcuts"""
        shortcuts = [
            ("/", "Chat Mode"),
            ("n", "New Agent"),
            ("‚Üë/‚Üì", "Select"), 
            ("Enter", "Details"),
            ("p", "Pause"),
            ("k", "Kill"),
            ("r", "Resume"),
            ("c", "Clear"),
            ("h", "Help"),
            ("q", "Quit")
        ]
        
        shortcut_text = Text()
        for key, desc in shortcuts:
            shortcut_text.append(f"[{key}]", style="bold cyan")
            shortcut_text.append(f" {desc}  ", style="white")
        
        return Panel(
            Align.center(shortcut_text),
            style="dim"
        )

        
    def _render_chat_input(self) -> Panel:
        """Render the chat input panel"""
        if self.workspace_state.chat_input_mode:
            # Input mode - show text input with cursor
            input_text = Text()
            input_text.append("üí¨ Agent Command: ", style="bold cyan")
            
            # Add text with cursor
            text_before_cursor = self.workspace_state.chat_input_text[:self.workspace_state.chat_cursor_position]
            cursor_char = self.workspace_state.chat_input_text[self.workspace_state.chat_cursor_position:self.workspace_state.chat_cursor_position+1] or " "
            text_after_cursor = self.workspace_state.chat_input_text[self.workspace_state.chat_cursor_position+1:]
            
            input_text.append(text_before_cursor, style="white")
            input_text.append(cursor_char, style="black on white")  # Cursor highlight
            input_text.append(text_after_cursor, style="white")
            
            # Add instructions
            instructions = Text()
            instructions.append("\n‚ú® Type your command for the agent, then press ", style="dim")
            instructions.append("Enter", style="bold green")
            instructions.append(" to spawn ‚Ä¢ ", style="dim")
            instructions.append("Esc", style="bold red")
            instructions.append(" to cancel", style="dim")
            
            combined = Text.assemble(input_text, instructions)
            
            return Panel(
                combined,
                title="üöÄ Agent Command Input",
                border_style="bright_green",
                style="on dark_blue"
            )
        else:
            # Normal mode - show recent commands and prompt to start typing
            content = Text()
            
            if self.workspace_state.chat_history:
                content.append("üìù Recent Commands:\n", style="bold yellow")
                for i, cmd in enumerate(self.workspace_state.chat_history[-3:], 1):
                    content.append(f"  {i}. {cmd}\n", style="dim white")
                content.append("\n")
                
            content.append("üí≠ Press ", style="cyan")
            content.append("'/'", style="bold white")
            content.append(" or ", style="cyan") 
            content.append("Enter", style="bold white")
            content.append(" to start typing agent commands", style="cyan")
            
            return Panel(
                content,
                title="üí¨ Agent Command Center",
                border_style="blue"
            )
        
    def _render_frame(self):
        """Render a complete frame"""
    # Update layout panels
    self.layout["header"].update(self._render_header())
    self.layout["agents_panel"].update(self._render_agents_panel())
    self.layout["thinking_panel"].update(self._render_thinking_panel())
    self.layout["output_panel"].update(self._render_output_panel())
    self.layout["chat_input"].update(self._render_chat_input())  # Add chat input panel
    self.layout["footer"].update(self._render_footer())
        
    def _handle_keyboard_input(self):

    def _handle_chat_input(self, key: str):
        """Handle keyboard input in chat input mode"""
        if key == '\x1b':  # ESC - exit chat mode
            self.workspace_state.chat_input_mode = False
            self.workspace_state.chat_input_text = ""
            self.workspace_state.chat_cursor_position = 0
            self.workspace_state.status_message = "Chat mode cancelled"
            
        elif key in ['\r', '\n']:  # Enter - submit command
            command = self.workspace_state.chat_input_text.strip()
            if command:
                # Add to history
                self.workspace_state.chat_history.append(command)
                if len(self.workspace_state.chat_history) > 10:  # Keep only last 10
                    self.workspace_state.chat_history.pop(0)
                
                # Spawn agent with custom command
                self._spawn_agent_with_command(command)
                
                # Exit chat mode
                self.workspace_state.chat_input_mode = False
                self.workspace_state.chat_input_text = ""
                self.workspace_state.chat_cursor_position = 0
                self.workspace_state.status_message = f"üöÄ Spawning agent: {command[:50]}..."
            else:
                self.workspace_state.status_message = "Empty command - please type something"
                
        elif key == '\x7f':  # Backspace
            if self.workspace_state.chat_cursor_position > 0:
                text = self.workspace_state.chat_input_text
                self.workspace_state.chat_input_text = (
                    text[:self.workspace_state.chat_cursor_position-1] + 
                    text[self.workspace_state.chat_cursor_position:]
                )
                self.workspace_state.chat_cursor_position -= 1
                
        elif len(key) == 1 and key.isprintable():  # Regular character
            # Insert character at cursor position
            text = self.workspace_state.chat_input_text
            self.workspace_state.chat_input_text = (
                text[:self.workspace_state.chat_cursor_position] + 
                key + 
                text[self.workspace_state.chat_cursor_position:]
            )
            self.workspace_state.chat_cursor_position += 1
            
        # Handle cursor movement (left/right arrows)
        elif key == '\x1b[C':  # Right arrow
            if self.workspace_state.chat_cursor_position < len(self.workspace_state.chat_input_text):
                self.workspace_state.chat_cursor_position += 1
        elif key == '\x1b[D':  # Left arrow  
            if self.workspace_state.chat_cursor_position > 0:
                self.workspace_state.chat_cursor_position -= 1

    def _spawn_agent_with_command(self, command: str):
        """Spawn an agent with a specific command/task"""
        if self._integration_initialized and self.mcp_orchestrator:
            # Use real MCP agent with custom command
            asyncio.create_task(self._spawn_mcp_agent_with_command(command))
        else:
            # Fallback to demo agent with custom command
            agent_id = str(uuid.uuid4())[:8]
            agent = Agent(
                id=agent_id,
                name=f"Custom-{len(self.workspace_state.agents) + 1}",
                command=command,  # Use the actual user command
                status=AgentStatus.SPAWNING,
                created_at=datetime.now()
            )
            
            self.workspace_state.agents[agent_id] = agent
            self.workspace_state.total_agents_spawned += 1
            self.workspace_state.selected_agent_id = agent_id
            
            # Start demo agent behavior with custom task
            threading.Thread(target=self._demo_agent_behavior_with_command, args=(agent_id, command), daemon=True).start()
    
    async def _spawn_mcp_agent_with_command(self, command: str):
        """Spawn a real MCP agent with custom command."""
        try:
            from .mcp_agent_orchestrator import MCPAgentType
            
            # Determine agent type based on command content
            command_lower = command.lower()
            if 'code' in command_lower or 'implement' in command_lower or 'fix' in command_lower:
                agent_type = MCPAgentType.CODEX
            elif 'review' in command_lower or 'analyze' in command_lower:
                agent_type = MCPAgentType.CLAUDE
            elif 'test' in command_lower or 'simple' in command_lower:
                agent_type = MCPAgentType.OLLAMA
            else:
                agent_type = MCPAgentType.CODER
            
            # Spawn the MCP agent with user's command
            session_id = await self.mcp_orchestrator.spawn_agent(
                agent_type=agent_type,
                objective=command,
                context={
                    "repo": ".",
                    "write_paths": ["src/agentsmcp/ui/v4/"],
                    "priority": 1,
                    "user_request": True  # Mark as user-initiated
                }
            )
            
            # Start thinking session if available
            if self.thinking_integrator:
                thinking_session_id = await self.thinking_integrator.start_thinking_session(
                    agent_id=session_id,
                    objective=command
                )
                
                # Simulate thinking process with user command
                asyncio.create_task(
                    self.thinking_integrator.simulate_mcp_thinking_process(
                        thinking_session_id, command
                    )
                )
            
            self.workspace_state.total_agents_spawned += 1
            self.workspace_state.selected_agent_id = session_id
            
        except Exception as e:
            logger.error(f"Failed to spawn MCP agent with command: {e}")
            # Fallback to demo agent
            self._spawn_demo_agent_with_command(command)
    
    def _spawn_demo_agent_with_command(self, command: str):
        """Spawn a demo agent with custom command as fallback."""
        agent_id = str(uuid.uuid4())[:8]
        agent = Agent(
            id=agent_id,
            name=f"Custom-{len(self.workspace_state.agents) + 1}",
            command=command,
            status=AgentStatus.SPAWNING,
            created_at=datetime.now()
        )
        
        self.workspace_state.agents[agent_id] = agent
        self.workspace_state.total_agents_spawned += 1
        self.workspace_state.selected_agent_id = agent_id
        
        # Start demo agent behavior with custom task
        threading.Thread(target=self._demo_agent_behavior_with_command, args=(agent_id, command), daemon=True).start()
    
    def _demo_agent_behavior_with_command(self, agent_id: str, command: str):
        """Demo agent behavior with custom command for testing"""
        agent = self.workspace_state.agents.get(agent_id)
        if not agent:
            return
            
        try:
            # Spawning phase
            time.sleep(1)
            agent.status = AgentStatus.THINKING
            agent.started_at = datetime.now()
            agent.current_task = f"Analyzing: {command}"
            
            # Thinking phase with command-specific thoughts
            thoughts = [
                f"User requested: {command}",
                "Breaking down this task into components",
                "Analyzing requirements and constraints", 
                "Planning approach and execution strategy",
                "Identifying tools and resources needed",
                "Ready to begin implementation"
            ]
            
            for i, thought in enumerate(thoughts):
                if agent_id not in self.workspace_state.agents:
                    return
                    
                agent.add_thought(thought)
                agent.progress = (i + 1) / len(thoughts) * 0.3  # 30% during thinking
                time.sleep(1.5)
                
            # Execution phase with command-specific steps
            agent.status = AgentStatus.EXECUTING
            agent.current_task = f"Executing: {command}"
            
            # Generate execution steps based on command type
            if 'code' in command.lower() or 'implement' in command.lower():
                execution_steps = [
                    "Setting up development environment",
                    "Analyzing existing codebase",
                    "Writing code implementation",
                    "Adding tests and documentation",
                    "Running validation checks",
                    "Optimizing and refining code"
                ]
            elif 'analyze' in command.lower() or 'review' in command.lower():
                execution_steps = [
                    "Loading and parsing input data",
                    "Performing detailed analysis",
                    "Identifying patterns and insights",
                    "Generating comprehensive report",
                    "Validating findings"
                ]
            else:
                execution_steps = [
                    "Initializing task execution",
                    "Processing user requirements",
                    "Implementing requested changes",
                    "Validating results",
                    "Finalizing deliverables"
                ]
            
            for i, step in enumerate(execution_steps):
                if agent_id not in self.workspace_state.agents:
                    return
                    
                agent.add_output(f"‚úì {step}")
                agent.progress = 0.3 + (i + 1) / len(execution_steps) * 0.7  # 30-100%
                agent.current_task = step
                time.sleep(2)
                
            # Completion with custom message
            agent.status = AgentStatus.COMPLETED
            agent.completed_at = datetime.now()
            agent.progress = 1.0
            agent.current_task = f"Completed: {command}"
            agent.add_output(f"‚úÖ Successfully completed: {command}")
            
        except Exception as e:
            agent.status = AgentStatus.ERROR
            agent.error_count += 1
            agent.add_output(f"‚ùå Error executing '{command}': {str(e)}")
    """Process keyboard input"""
    key = self.keyboard_handler.get_key()
    if not key:
        return
        
    # Handle chat input mode
    if self.workspace_state.chat_input_mode:
        self._handle_chat_input(key)
        return
        
    # Normal navigation mode
    agent_ids = list(self.workspace_state.agents.keys())
    current_idx = -1
    if self.workspace_state.selected_agent_id:
        try:
            current_idx = agent_ids.index(self.workspace_state.selected_agent_id)
        except ValueError:
            pass
            
    if key == 'q':
        self._running = False
        self.workspace_state.status_message = "Shutting down..."
        
    elif key == 'n':
        self._spawn_new_agent()
        
    elif key == 'c':
        self.workspace_state.agents.clear()
        self.workspace_state.selected_agent_id = None
        self.workspace_state.status_message = "Cleared all agents"
        
    elif key in ['/', '\r', '\n']:  # Enter chat input mode
        self.workspace_state.chat_input_mode = True
        self.workspace_state.chat_input_text = ""
        self.workspace_state.chat_cursor_position = 0
        self.workspace_state.status_message = "üí¨ Chat mode: Type agent command"
        
    elif key == '\x1b':  # ESC sequence start
        # Handle arrow keys (ESC [ A/B/C/D)
        pass
        
    elif key in ['j', 'J'] or ord(key) == 10:  # j or Enter key
        if agent_ids and current_idx < len(agent_ids) - 1:
            self.workspace_state.selected_agent_id = agent_ids[current_idx + 1]
            
    elif key in ['k', 'K']:
        if agent_ids and current_idx > 0:
            self.workspace_state.selected_agent_id = agent_ids[current_idx - 1]
            
    elif key == 'p':
        self._pause_selected_agent()
        
    elif key == 'r':
        self._resume_selected_agent()
        
    elif key in ['x', 'X']:
        self._kill_selected_agent()
        
    elif key == 'h':
        self.workspace_state.status_message = "Keyboard shortcuts: /=chat, n=new, ‚Üë/‚Üì=select, p=pause, r=resume, x=kill, c=clear, q=quit"
            
    def _spawn_new_agent(self):
        """Spawn a new MCP agent or demo agent"""
        if self._integration_initialized and self.mcp_orchestrator:
            # Use real MCP agent
            asyncio.create_task(self._spawn_mcp_agent())
        else:
            # Fallback to demo agent
            agent_id = str(uuid.uuid4())[:8]
            agent = Agent(
                id=agent_id,
                name=f"Agent-{len(self.workspace_state.agents) + 1}",
                command="demo_task",
                status=AgentStatus.SPAWNING,
                created_at=datetime.now()
            )
            
            self.workspace_state.agents[agent_id] = agent
            self.workspace_state.total_agents_spawned += 1
            self.workspace_state.selected_agent_id = agent_id
            self.workspace_state.status_message = f"Spawned new agent {agent.name}"
            
            # Start demo agent behavior
            threading.Thread(target=self._demo_agent_behavior, args=(agent_id,), daemon=True).start()
    
    async def _spawn_mcp_agent(self):
        """Spawn a real MCP agent."""
        try:
            from .mcp_agent_orchestrator import MCPAgentType
            
            # Cycle through different agent types for demonstration
            agent_types = [
                MCPAgentType.CODEX,
                MCPAgentType.CLAUDE, 
                MCPAgentType.OLLAMA,
                MCPAgentType.CODER
            ]
            
            agent_type = agent_types[len(self.workspace_state.agents) % len(agent_types)]
            
            # Define some sample tasks
            tasks = [
                "Analyze the current codebase structure and suggest improvements",
                "Review the workspace controller for potential optimizations",
                "Generate documentation for the MCP integration components",
                "Implement a new feature for enhanced agent monitoring",
                "Debug and fix any issues in the orchestration layer"
            ]
            
            task = tasks[len(self.workspace_state.agents) % len(tasks)]
            
            # Spawn the MCP agent
            session_id = await self.mcp_orchestrator.spawn_agent(
                agent_type=agent_type,
                objective=task,
                context={
                    "repo": ".",
                    "write_paths": ["src/agentsmcp/ui/v4/"],
                    "priority": 1
                }
            )
            
            # Start thinking session if available
            if self.thinking_integrator:
                thinking_session_id = await self.thinking_integrator.start_thinking_session(
                    agent_id=session_id,
                    objective=task
                )
                
                # Simulate thinking process
                asyncio.create_task(
                    self.thinking_integrator.simulate_mcp_thinking_process(
                        thinking_session_id, task
                    )
                )
            
            self.workspace_state.total_agents_spawned += 1
            self.workspace_state.selected_agent_id = session_id
            self.workspace_state.status_message = f"Spawned MCP {agent_type.value} agent"
            
        except Exception as e:
            logger.error(f"Failed to spawn MCP agent: {e}")
            # Fallback to demo agent
            self._spawn_demo_agent()
    
    def _spawn_demo_agent(self):
        """Spawn a demo agent as fallback."""
        agent_id = str(uuid.uuid4())[:8]
        agent = Agent(
            id=agent_id,
            name=f"Demo-{len(self.workspace_state.agents) + 1}",
            command="demo_task",
            status=AgentStatus.SPAWNING,
            created_at=datetime.now()
        )
        
        self.workspace_state.agents[agent_id] = agent
        self.workspace_state.total_agents_spawned += 1
        self.workspace_state.selected_agent_id = agent_id
        self.workspace_state.status_message = f"Spawned demo agent {agent.name} (MCP not available)"
        
        # Start demo agent behavior
        threading.Thread(target=self._demo_agent_behavior, args=(agent_id,), daemon=True).start()
        
    def _demo_agent_behavior(self, agent_id: str):
        """Demo agent behavior for testing"""
        agent = self.workspace_state.agents.get(agent_id)
        if not agent:
            return
            
        try:
            # Spawning phase
            time.sleep(1)
            agent.status = AgentStatus.THINKING
            agent.started_at = datetime.now()
            agent.current_task = "Analyzing requirements"
            
            # Thinking phase with sequential thoughts
            thoughts = [
                "Let me break down this task into components",
                "I need to consider the user requirements carefully", 
                "Looking at available tools and capabilities",
                "Planning the execution strategy",
                "Ready to begin implementation"
            ]
            
            for i, thought in enumerate(thoughts):
                if agent_id not in self.workspace_state.agents:
                    return
                    
                agent.add_thought(thought)
                agent.progress = (i + 1) / len(thoughts) * 0.3  # 30% during thinking
                time.sleep(2)
                
            # Execution phase  
            agent.status = AgentStatus.EXECUTING
            agent.current_task = "Executing planned actions"
            
            execution_steps = [
                "Initializing execution environment",
                "Loading required modules and dependencies", 
                "Processing input data",
                "Applying transformations",
                "Generating intermediate results",
                "Performing validation checks",
                "Optimizing output format",
                "Finalizing results"
            ]
            
            for i, step in enumerate(execution_steps):
                if agent_id not in self.workspace_state.agents:
                    return
                    
                agent.add_output(step)
                agent.progress = 0.3 + (i + 1) / len(execution_steps) * 0.7  # 30-100%
                agent.current_task = step
                time.sleep(1.5)
                
            # Completion
            agent.status = AgentStatus.COMPLETED
            agent.completed_at = datetime.now()
            agent.progress = 1.0
            agent.current_task = "Task completed successfully"
            agent.add_output("‚úÖ Task completed successfully")
            
        except Exception as e:
            agent.status = AgentStatus.ERROR
            agent.error_count += 1
            agent.add_output(f"‚ùå Error: {str(e)}")
            
    def _pause_selected_agent(self):
        """Pause the selected agent"""
        if not self.workspace_state.selected_agent_id:
            return
            
        agent = self.workspace_state.agents.get(self.workspace_state.selected_agent_id)
        if agent and agent.status not in [AgentStatus.COMPLETED, AgentStatus.ERROR, AgentStatus.KILLED]:
            agent.status = AgentStatus.PAUSED
            self.workspace_state.status_message = f"Paused {agent.name}"
            
    def _resume_selected_agent(self):
        """Resume the selected agent"""
        if not self.workspace_state.selected_agent_id:
            return
            
        agent = self.workspace_state.agents.get(self.workspace_state.selected_agent_id)
        if agent and agent.status == AgentStatus.PAUSED:
            agent.status = AgentStatus.EXECUTING
            self.workspace_state.status_message = f"Resumed {agent.name}"
            
    def _kill_selected_agent(self):
        """Kill the selected agent"""
        if not self.workspace_state.selected_agent_id:
            return
            
        agent = self.workspace_state.agents.get(self.workspace_state.selected_agent_id)
        if agent and agent.status != AgentStatus.KILLED:
            agent.status = AgentStatus.KILLED
            agent.completed_at = datetime.now()
            agent.add_output("üî¥ Agent killed by user")
            self.workspace_state.status_message = f"Killed {agent.name}"
            
    async def run(self):
        """Main event loop - runs persistently like htop"""
        debug_mode = "--debug" in sys.argv or os.environ.get('AGENTSMCP_DEBUG', '').lower() in ('1', 'true', 'yes')
        
        if debug_mode:
            print("üöÄ [DEBUG] Entering WorkspaceController.run()", flush=True)
        
        self.workspace_state.status_message = "üöÄ Workspace Controller Started - Press 'h' for help"
        
        # Detect if we're in a non-TTY environment and adapt
        is_tty = sys.stdin.isatty()
        if debug_mode:
            print(f"üöÄ [DEBUG] TTY environment detected: {is_tty}", flush=True)
        
        try:
            if debug_mode:
                print("üöÄ [DEBUG] Starting keyboard handler...", flush=True)
            
            # Initialize MCP integration
            if debug_mode:
                print("üöÄ [DEBUG] Initializing MCP integration...", flush=True)
            await self._initialize_mcp_integration()
            
            # Only start keyboard handler in TTY environments
            if is_tty:
                self.keyboard_handler.start()
            else:
                if debug_mode:
                    print("üöÄ [DEBUG] Skipping keyboard handler in non-TTY environment", flush=True)
                
            self._running = True
            if debug_mode:
                print("üöÄ [DEBUG] Keyboard handler started, _running = True", flush=True)
                print(f"üöÄ [DEBUG] MCP integration initialized: {self._integration_initialized}", flush=True)
            
            if debug_mode:
                print("üöÄ [DEBUG] Creating Rich Live display...", flush=True)
            
            # Adjust Live display settings for non-TTY
            if not is_tty:
                if debug_mode:
                    print("üöÄ [DEBUG] Non-TTY: Using console output instead of Live display", flush=True)
                print("üöÄ Workspace Controller Demo Mode - Non-TTY Environment", flush=True)
                print("=" * 60, flush=True)
                
                # Spawn a demo agent automatically to showcase functionality
                print("ü§ñ Spawning demo agent to showcase workspace capabilities...", flush=True)
                self._spawn_new_agent()
                
                # For non-TTY, just run the main loop without Live display
                loop_count = 0
                while self._running and loop_count < 200:  # Extended demo in non-TTY
                    loop_count += 1
                    
                    current_time = time.time()
                    
                    # Handle input (will be no-op in non-TTY)
                    self._handle_keyboard_input()
                    
                    # Update active agent count
                    self.workspace_state.active_agents = sum(
                        1 for agent in self.workspace_state.agents.values()
                        if agent.status not in [AgentStatus.COMPLETED, AgentStatus.ERROR, AgentStatus.KILLED]
                    )
                    
                    # Render frame if needed (print to console in non-TTY)
                    if current_time - self._last_render >= self._render_interval:
                        if loop_count % 20 == 0:  # Show UI every 20 iterations (every 2 seconds)
                            print("\n" + "‚îÄ" * 60, flush=True)
                            print(f"üöÄ Workspace Status [Iteration {loop_count}/200]", flush=True)
                            print(f"   Active agents: {self.workspace_state.active_agents}", flush=True)
                            print(f"   Total agents spawned: {self.workspace_state.total_agents_spawned}", flush=True)
                            
                            # Show agent details
                            for agent_id, agent in self.workspace_state.agents.items():
                                status_icon = {
                                    AgentStatus.SPAWNING: "üü°",
                                    AgentStatus.THINKING: "üß†", 
                                    AgentStatus.EXECUTING: "‚ö°",
                                    AgentStatus.WAITING: "‚è≥",
                                    AgentStatus.COMPLETED: "‚úÖ",
                                    AgentStatus.ERROR: "‚ùå",
                                    AgentStatus.PAUSED: "‚è∏Ô∏è",
                                    AgentStatus.KILLED: "üî¥"
                                }.get(agent.status, "‚ùì")
                                
                                print(f"   {status_icon} {agent.name} ({agent.status.value}) - {agent.current_task}", flush=True)
                                print(f"      Progress: {agent.progress:.0%} | Thoughts: {len(agent.sequential_thoughts)} | Output lines: {len(agent.output_lines)}", flush=True)
                                
                        self._last_render = current_time
                        
                    # Small sleep to prevent excessive CPU usage
                    await asyncio.sleep(0.1)  # Longer sleep in non-TTY
                    
                print("\nüöÄ Demo completed! Workspace Controller would run indefinitely in TTY environment.", flush=True)
                print("üí° In a real terminal, you could interact with agents using keyboard shortcuts:", flush=True)
                print("   ‚Ä¢ Press 'n' to spawn new agents", flush=True) 
                print("   ‚Ä¢ Use ‚Üë/‚Üì to select agents", flush=True)
                print("   ‚Ä¢ Press 'p' to pause, 'r' to resume, 'k' to kill agents", flush=True)
                print("   ‚Ä¢ Press 'q' to quit", flush=True)
            else:
                # TTY environment - use Rich Live display
                with Live(self.layout, refresh_per_second=10, console=self.console) as live:
                    self.live = live
                    print("üöÄ [DEBUG] Rich Live display created, entering main loop...", flush=True)
                    
                    loop_count = 0
                    while self._running:
                        loop_count += 1
                        if loop_count % 200 == 0:  # Print debug every ~10 seconds (200 * 0.05s)
                            print(f"üöÄ [DEBUG] Main loop iteration {loop_count}, _running = {self._running}", flush=True)
                        
                        current_time = time.time()
                        
                        # Handle input
                        self._handle_keyboard_input()
                        
                        # Update active agent count
                        self.workspace_state.active_agents = sum(
                            1 for agent in self.workspace_state.agents.values()
                            if agent.status not in [AgentStatus.COMPLETED, AgentStatus.ERROR, AgentStatus.KILLED]
                        )
                        
                        # Render frame if needed
                        if current_time - self._last_render >= self._render_interval:
                            self._render_frame()
                            self._last_render = current_time
                            
                        # Small sleep to prevent excessive CPU usage
                        await asyncio.sleep(0.05)
                        
                    print("üöÄ [DEBUG] Exited main loop", flush=True)
                    
        except KeyboardInterrupt:
            print("üöÄ [DEBUG] KeyboardInterrupt in run()", flush=True)
            self.workspace_state.status_message = "Received interrupt signal"
        except Exception as e:
            print(f"üöÄ [DEBUG] Exception in run(): {e}", flush=True)
            import traceback
            traceback.print_exc()
            sys.stdout.flush()
            sys.stderr.flush()
            self.workspace_state.status_message = f"Error: {str(e)}"
        finally:
            print("üöÄ [DEBUG] In finally block, stopping keyboard handler...", flush=True)
            if is_tty:
                self.keyboard_handler.stop()
            self.console.print("\n[bold cyan]üöÄ Workspace Controller Shutdown Complete[/]")
            print("üöÄ [DEBUG] run() method complete", flush=True)
            

def main():
    """Entry point for the workspace controller"""
    # Check if debug mode is enabled
    debug_mode = "--debug" in sys.argv or os.environ.get('AGENTSMCP_DEBUG', '').lower() in ('1', 'true', 'yes')
    
    if debug_mode:
        print("üöÄ [DEBUG] Starting Workspace Controller main()", flush=True)
        print(f"üöÄ [DEBUG] TTY detected: {sys.stdin.isatty()}", flush=True)
        print(f"üöÄ [DEBUG] Environment AGENTSMCP_FORCE_RICH: {os.environ.get('AGENTSMCP_FORCE_RICH', 'not set')}", flush=True)
        print(f"üöÄ [DEBUG] Current working directory: {os.getcwd()}", flush=True)
    
    try:
        if debug_mode:
            print("üöÄ [DEBUG] Creating WorkspaceController instance...", flush=True)
        controller = WorkspaceController()
        if debug_mode:
            print("üöÄ [DEBUG] WorkspaceController created successfully", flush=True)
        
        if debug_mode:
            print("üöÄ [DEBUG] Starting async event loop...", flush=True)
        asyncio.run(controller.run())
        if debug_mode:
            print("üöÄ [DEBUG] Event loop completed", flush=True)
        
    except KeyboardInterrupt:
        if debug_mode:
            print("\nüöÄ [DEBUG] KeyboardInterrupt received", flush=True)
        print("üöÄ Workspace Controller Shutdown", flush=True)
    except Exception as e:
        print(f"‚ùå Fatal Error: {e}", flush=True)
        if debug_mode:
            import traceback
            print("üöÄ [DEBUG] Full traceback:", flush=True)
            traceback.print_exc()
        sys.exit(1)
        
    if debug_mode:
        print("üöÄ [DEBUG] main() function complete", flush=True)


if __name__ == "__main__":
    main()